# 1. Реалізація пошуку шляхів для ігрового штучного інтелекту за допомогою NavMesh

Іноді нам потрібно, щоб АІ-персонажі бродили по ігровому рівню, слідуючи по грубо окресленому або точно заданому шляху. Наприклад в гоночній грі АІ-противники повинні їхати по дорозі, а в RTS юніти повинні вміти переміщатися в потрібну точку, рухаючись по рельєфу, а також враховувати положення один одного.

Уникнення перешкод - це проста поведінка, що дозволяє АІ-сутностям досягати цільових точок. Важливо зауважити, що основа поведінки нашої АІ-сутності є уникнення перешкод і досягнення мети (гравця). Ця проста поведінка визначає найбільш ефективний і найкоротший шлях.

Для пошуку шляхів АІ сцена повинна бути представлена в певному форматі; на 2D-карті використовується двомірна сітка (масив) для пошуку шляхів алгоритмом A*. АІ-агенти повинні знати, де є перешкоди, особливо статичні. Робота з униканням колізій між динамічно рухомими об'єктами - це інше питання, який зазвичай називається steering behavior. В Unity є вбудований інструмент для генерації NavMesh, що представляє сцену в контексті, зручному для пошуку АІ-агентами оптимального шляху до цілі.

По-перше, слід позначити всю геометрію в сцені, запікаєму в NavMesh, як Navigation Static, по-друге, слід зробити ігрові об'єкти статичними (поставити прапорець Static для всіх їх властивостей)

# Запікання навігаційного меша

Вікно Navmesh має 4 вкладки:
-Agents
-Areas
-Bake
-Object

Вкладка Agents: має в собі налаштування самих АІ-агентів (радіус і висота агента, висота перешкоди яку може подолати агент, ім'я агента, максимальний кут на який може підніматись агент)

Вкладка Areas: Unity має кілька типів областей, які неможливо змінювати: Walkable, Not Walkable і Jump. Також є можливість присвоєння назв і створення нових областей.
Області (Areas) служать двом цілям: робити області доступними або недоступними для агента, а також позначати області як менш бажані з точки зору витрат на переміщення. 

Третя вкладка Bake - напевно, найважливіша. Вона дозволяє створювати сам NavMesh для сцени.
Параметри розміру агента на цій вкладці визначають, як агенти взаємодіятимуть із середовищем, в той час як параметри у вкладці Agents керують взаємодією з іншими агентами і рухомими об'єктами
Натиснувши кнопку Bake ми згенеруємо NavMesh на нашому ігровому рівні.

Остання вкладка Object: три кнопки - All, Mesh Renderers і Terrains - використовуються як фільтри сцени. Вони корисні при роботі в складних сценах з безліччю об'єктів в ієрархії.

# Застосування Nav Mesh Agent
Тепер, коли ми налаштували сцену з NavMesh, нам потрібен спосіб, яким агент зможе використовувати цю інформацію. На щастя для нас, в Unity є компонент Nav Mesh Agent, який можна перетягнути на персонажа. На нашій сцені є ігровий об'єкт з назвою Player, до якого вже прикріплений компонент.
Цей компонент виконує за нас 90% важкої роботи: прокладання шляху, уникнення перешкод і так далі. Єдине, що потрібно - передати агенту цільову точку.

# Задання цільової точки

Після налаштування AI-агента нам потрібен спосіб повідомити йому, куди рухатися. У нашому прикладі проекту є скрипт з назвою Target.cs, що виконує саме цю задачу.

Це простий клас, який виконує три дії:
1.«Вистрілює» промінь з камери до позиції миші в світі
2.Оновлює позицію маркера
3.Оновлює властивість точки призначення для всіх агентів NavMesh

Весь клас виглядає наступним чином:

```cs
using UnityEngine;
using UnityEngine.AI;

public class Target : MonoBehaviour
{
    private NavMeshAgent[] navAgents;
    public Transform targetMarker;

    private void Start()
    {
      navAgents = FindObjectsOfType(typeof(NavMeshAgent)) as NavMeshAgent[];
    }

    private void UpdateTargets(Vector3 targetPosition)
    {
      foreach(NavMeshAgent agent in navAgents) 
      {
        agent.destination = targetPosition;
      }
    }

    private void Update()
    {
        if (GetInput()) 
        {
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hitInfo;

            if (Physics.Raycast(ray.origin, ray.direction, out hitInfo)) 
            {
                Vector3 targetPosition = hitInfo.point;
                UpdateTargets(targetPosition);
                targetMarker.position = targetPosition;
            }
        }
    }

    private bool GetInput() 
    {
        if (Input.GetMouseButtonDown(0)) 
        {
            return true;
        }
        return false;
    }

    private void OnDrawGizmos() 
    {
        Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * 5, Color.red);
    }
}
```

Тут відбуваються такі дії: в методі Start ми ініуіюємо масив navAgents за допомогою методу FindObjectsOfType().

Метод UpdateTargets() проходить по нашому масиву navAgents і задає для них цільову точку в заданому Vector3. Це ключ до роботи коду. Для отримання цільової точки ви можете використовувати будь-який механізм, і щоб агент перемістився туди, досить задати поле NavMeshAgent.destination; все інше зробить агент.

У нашому прикладі для переміщення використовуються кліки, тому коли гравець натискає мишею, ми випускаємо промінь з камери в світ у напрямку курсора миші, і якщо він з чимось перетнеться, то ми призначаємо точку зіткнення нової targetPosition агента.

Отже, поєднання цих можливостей надає вам зручний готовий інструмент. Ви можете досить швидко створити просту гру за допомогою функціоналу NavMesh.

# 4. Організація роботи зброї

Поведінка та взаємодія зі зброєю реалізована з використанням розподілу логіки по трьом різним класам (скриптам).

## WeaponSO
Цей клас є спадкоємцем ScriptableObject, його зручно використовувати для того, щоб створювати в Unity різні об'єкти, що об'єднані спільними характеристиками та зручно працювати з ними в інтерфейсі Unity-редактора. Також цей клас зберігає внутрішні параметри зброї, такі як шкода за кулю, кількість пострілів у секунду, тощо. Ще цей клас зберігає параметри, які можуть змінюватися по ходу гри, такі як поточна кількість набоїв у магазині.

Крім цього він містить наступні параметри, які змінюються відповідно до конкретного екземпляру зброї:

- ```string name``` - назва зброї в інвентарі.
- ```int weaponID``` - унікальний ідентифікаційний номер зброї.
- ```float damage``` - кількість шкоди, яка завдає одна куля.
- ```float damageSpread``` - максимальний відхил шкоди в обидва боки, ```0``` - шкода завжди буде відповідати значенню damage, ```100``` - якщо значення змінної damage дорівнює ```100```, то підсумкова шкода буде належати інтервалу ```[0, 200]``` та визначатися випадково.
- ```int maxBulletsInMagazine``` - максимальна кількість набоїв у магазині.
- ```int maxAllAmmo``` - максимальна кількість набоїв у інвентарі гравця для даної зброї.
- ```int currentBulletsInMagazine``` - поточна кількість набоїв у магазині.
- ```int allAmmo``` - поточна кількість набоїв у інвентарі гравця для даної зброї.
- ```int bulletsPerShot``` - кількість куль, що вистрілює зброя за один постріл.
- ```float reloadTime``` - час, що витрачається на перезарядку зброї у секундах.
- ```float shotSpread``` - розкид збої при пострілі на 100 метрів.
- ```float shotsPerSecond``` - кількість пострілів у секунду.
- ```float maxShotDistance``` - максимальна відстань ефективного пострілу у метрах.
- ```bool isAutomatic``` - визначає те, чи автоматична зброя (впливає на те, чи можна робити постріли не відтискаючи кнопку пострілу).
- ```AudioClip shotSound``` - звук пострілу.
- ```AudioClip noAmmoSound``` - звук, який програється, коли гравець намагаєтсья зробити постріл, але в магазині немає набоїв.
- ```AudioClip reloadSound``` - звук, який програється при перезарядці зброї.
```bool isReloading``` - визначає те, чи перезаряджається зброя у даний момент.

## Weapon
Цей клас відповідає за внутрішню логіку та поведінку зброї. Містить функції та події які відповідають за постріл, перезарядку, тощо.

```ShotResult``` - ```enum```, що відповідає за відповідь зброї на спробу зробити постріл. Існує декілька варіантів значень цього ```enum'y```, а саме:
- ```NoAmmoInBackpack``` - відсутні набої в інвентарі.
- ```NoAmmoInMagazine``` - відсутні набої у магазині.
- ```ShotSuccesful``` - вистріл виконано успішно.
- ```TooFast``` - пройшло надто мало часу з останнього пострілу.

```TryShoot()``` - метод, який робить спробу пострілу та повертає значення типу ```ShotResult```, після цього клас. ```GunController``` обробляє це значення, та виконує відповідний метод (робить постріл, програє звук перезарядки, тощо).
```Reload()``` - метод, який виконує перезарядку.

## GunController

В цьому класі реалізовані методи, що відповідають за програвання звуків, візуалізацію ефектів та фізичну взаємодію куль та ігрового оточення.
```NoAmmo()``` - метод, що програє звук пострілу коли в магазині немає набоїв.
```Reload()``` - метод, що програє звук перезарядки та викликає метод ```Reload()``` з прив'язаного ```Weapon```.
```Shoot()``` - метод, що програє звук та візуалізує ефекет пострілу, а також завдає шкоду сутностям, з яким взаємодіє куля.
```TryShoot()``` - метод, що викликає метод ```TryShoot()``` з прив'язаного ```Weapon```, і виходячи з поверненого значення викликає вишеперелічені методи.